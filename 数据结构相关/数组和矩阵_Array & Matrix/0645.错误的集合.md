# 0645.错误的集合

## 题目描述

集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回 

**示例 1：**

```html
输入：nums = [1,2,2,4]
输出：[2,3]
```

**示例 2：**

```html
输入：nums = [1,1]
输出：[1,2]
```

 **提示：**

- `2 <= nums.length <= 104`
- `1 <= nums[i] <= 104`

## 解题方法

### 数学方法（1）

**思路：** 参考 [一题三解：「计数」&「数学」&「桶排序」](https://leetcode.cn/problems/set-mismatch/solutions/857445/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/)   作者：宫水三叶 

利用数值范围为 [1,*n*]，只有一个数重复和只有一个缺失的特性，进行「作差」求解

- 令 `[1,n]` 的求和为 `tot`，这部分可以使用「等差数列求和公式」直接得出：$tot= \frac{n(1+n)}{2}$ 
- 令数组 `nums` 的求和值为 `sum`，由循环累加可得
- 令数组 `sums` 去重求和值为 `set`，由循环配合「哈希表/数组」累加可得

最终答案为 `(重复元素, 缺失元素) = (sum-set, tot-set)` 

```c
int* findErrorNums(int* nums, int numsSize, int* returnSize) {
    int n = numsSize;
    int* cnts = (int*)calloc(n + 1, sizeof(int)); // 动态分配并初始化计数数组
    int tot = (1 + n) * n / 2;
    int sum = 0, set = 0;

    for (int i = 0; i < n; i++) {
        sum += nums[i];
        if (cnts[nums[i]] == 0) {
            set += nums[i];
        }
        cnts[nums[i]] = 1;
    }

    free(cnts); // 释放内存

    // 构造返回结果数组
    int* result = (int*)malloc(2 * sizeof(int));
    result[0] = sum - set;   // 重复的数字
    result[1] = tot - set;   // 丢失的数字

    *returnSize = 2;  // 设置返回数组的大小

    return result;
}
```

### 数学方法（2）

### 解决思路：

1. 原本正确的集合 `S` 的元素和为：`sum_ideal = n * (n + 1) / 2`

2. 原本正确的集合 `S` 的元素平方和为：`sum_square_ideal = n * (n + 1) * (2n + 1) / 6`

3. 错误集合 `nums` 的元素和为：`sum_nums`

4. 错误集合 `nums` 的元素平方和为：`sum_square_nums`

5. 设重复的数字为 `dup`，丢失的数字为 `miss`，我们可以得到以下方程：

   - `dup - miss = sum_nums - sum_ideal`
   - `dup^2 - miss^2 = sum_square_nums - sum_square_ideal`

   通过这两个方程可以解出  `dup` 和  `miss`

```c
int* findErrorNums(int* nums, int numsSize, int* returnSize) {
    int sum_ideal = numsSize * (numsSize + 1) / 2;
    long long sum_square_ideal = (long long)numsSize * (numsSize + 1) * (2 * numsSize + 1) / 6;
    
    int sum_nums = 0;
    long long sum_square_nums = 0;
    
    for (int i = 0; i < numsSize; i++) {
        sum_nums += nums[i];
        sum_square_nums += (long long)nums[i] * nums[i];
    }
    
    // 差值计算
    int diff_sum = sum_nums - sum_ideal;
    long long diff_square_sum = sum_square_nums - sum_square_ideal;
    
    // 通过公式 dup^2 - miss^2 = (dup - miss) * (dup + miss)
    int sum_dup_miss = (int)(diff_square_sum / diff_sum);
    
    int dup = (sum_dup_miss + diff_sum) / 2;
    int miss = sum_dup_miss - dup;
    
    // 返回结果
    int* result = (int*)malloc(2 * sizeof(int));
    result[0] = dup;
    result[1] = miss;
    *returnSize = 2;
    
    return result;
}

```

### 排序法

通过对数组进行排序，我们可以轻松找到重复和丢失的数字

```c
int cmp(const void* a, const void* b) {
    return *(int*)a - *(int*)b;
}

int* findErrorNums(int* nums, int numsSize, int* returnSize) {
    qsort(nums, numsSize, sizeof(int), cmp);  // 先排序数组

    int* result = (int*)malloc(2 * sizeof(int));
    *returnSize = 2;
    
    int duplicate = -1, missing = 1;  // 初始化重复和丢失的数
    for (int i = 1; i < numsSize; i++) {
        if (nums[i] == nums[i - 1]) {
            duplicate = nums[i];
        } else if (nums[i] > nums[i - 1] + 1) {
            missing = nums[i - 1] + 1;
        }
    }
    
    // 如果遍历结束后仍未找到丢失的数字，说明缺失的是最后一个数
    if (nums[numsSize - 1] != numsSize) {
        missing = numsSize;
    }
    
    result[0] = duplicate;
    result[1] = missing;
    return result;
}
```

### 哈希表法

使用哈希表来记录数组中每个数字的出现次数。通过哈希表可以轻松找到重复的数字和缺失的数字

```c
int* findErrorNums(int* nums, int numsSize, int* returnSize) {
    int* cnts = (int*)calloc(numsSize + 1, sizeof(int));  // 创建计数数组
    int* result = (int*)malloc(2 * sizeof(int));  // 存储结果
    *returnSize = 2;
    
    // 统计每个数字出现的次数
    for (int i = 0; i < numsSize; i++) {
        cnts[nums[i]]++;
    }
    
    // 找出重复的数字和丢失的数字
    for (int i = 1; i <= numsSize; i++) {
        if (cnts[i] == 2) {
            result[0] = i;  // 重复的数字
        } else if (cnts[i] == 0) {
            result[1] = i;  // 丢失的数字
        }
    }
    
    free(cnts);  // 释放计数数组内存
    return result;
}
```

### 标记法

使用数组本身作为哈希表的一部分，可以在不使用额外空间的情况下完成任务。我们可以遍历数组，对于每个数字 `nums[i]`，将其作为索引，并将相应位置上的数字变为负数来标记该数字是否出现过。最后，再次遍历数组，正数位置的索引即为丢失的数字，重复的数字就是再次出现为负数的索引

```c
int* findErrorNums(int* nums, int numsSize, int* returnSize) {
    int* result = (int*)malloc(2 * sizeof(int));  // 存储结果
    *returnSize = 2;
    
    // 标记出现的数字
    for (int i = 0; i < numsSize; i++) {
        int index = abs(nums[i]) - 1;
        if (nums[index] < 0) {
            result[0] = index + 1;  // 找到重复的数字
        } else {
            nums[index] = -nums[index];  // 标记为负数
        }
    }
    
    // 查找丢失的数字
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] > 0) {
            result[1] = i + 1;  // 找到丢失的数字
        }
    }
    
    return result;
}
```

