# 0667.优美的排列Ⅱ

## 题目描述

给你两个整数 `n` 和 `k` ，请你构造一个答案列表 `answer` ，该列表应当包含从 `1` 到 `n` 的 `n` 个不同正整数，并同时满足下述条件：

假设该列表是 `answer = [a1, a2, a3, ... , an]` ，那么列表 `[|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|]` 中应该有且仅有 `k` 个不同整数

返回列表 `answer` 。如果存在多种答案，只需返回其中 **任意一种** 

 **示例 1：**

```html
输入：n = 3, k = 1
输出：[1, 2, 3]
解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1
```

**示例 2：**

```html
输入：n = 3, k = 2
输出：[1, 3, 2]
解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2
```

 **提示：**

- `1 <= k < n <= 104`

## 解题方法

**思路** 参考 [优美的排列 II【脑筋急转弯】](https://leetcode.cn/problems/beautiful-arrangement-ii/solutions/1809575/you-by-capital-worker-rnwi/) 作者：京城打工人

![0667解题思路](https://github.com/YuCaiH/LeetCode_CyC2018/tree/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5_Array%20%26%20Matrix/images)

```c
int* constructArray(int n, int k, int* returnSize) {
    int* ans = (int*)malloc(n * sizeof(int));
    *returnSize = n;
    int i = 0;			//用来跟踪当前填充数组的位置
    int p = 1, q = n;	//用于填充数组

    //构造前k个元素(相当妙~~)
    for (int j = 0; j < k; j++) {	
        if (j % 2 == 0) {
            ans[i++] = p++;
        } else {
            ans[i++] = q--;
        }
    }

    //处理剩余元素
    if (k % 2 == 0) {
        while (i < n) {
            ans[i++] = q--;
        }
    } else {
        while (i < n) {
            ans[i++] = p++;
        }
    }
    //返回结果
    return ans;
}
```

