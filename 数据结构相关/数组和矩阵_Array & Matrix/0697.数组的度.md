# 0697.数组的度

## 题目描述

给定一个非空且只包含非负数的整数数组 `nums`，数组的 **度** 的定义是指数组里任一元素出现频数的最大值。

你的任务是在 `nums` 中找到与 `nums` 拥有相同大小的度的最短连续子数组，返回其长度

 **示例 1：**

```html
输入：nums = [1,2,2,3,1]
输出：2
解释：
输入数组的度是 2 ，因为元素 1 和 2 的出现频数最大，均为 2 
连续子数组里面拥有相同度的有如下所示：
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组 [2, 2] 的长度为 2 ，所以返回 2 
```

**示例 2：**

```html
输入：nums = [1,2,2,3,1,4,2]
输出：6
解释：
数组的度是 3 ，因为元素 2 重复出现 3 次
所以 [2,2,3,1,4,2] 是最短子数组，因此返回 6 
```

 **提示：**

- `nums.length` 在 `1` 到 `50,000` 范围内。
- `nums[i]` 是一个在 `0` 到 `49,999` 范围内的整数。

## 解题方法

思路：

参考：【 [详细分析题意与思路，简洁代码，看完必懂](https://leetcode.cn/problems/degree-of-an-array/solutions/610890/xiang-xi-fen-xi-ti-yi-yu-si-lu-jian-ji-d-nvdy/) 作者：负雪明烛】【[数组的度](https://leetcode.cn/problems/degree-of-an-array/solutions/610337/shu-zu-de-du-by-leetcode-solution-ig97/) 作者：力扣官方题解】

![0697思路01](https://github.com/YuCaiH/LeetCode_CyC2018/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5_Array%20%26%20Matrix/images/0697%E6%80%9D%E8%B7%AF01.jpg)

![0697思路02](https://github.com/YuCaiH/LeetCode_CyC2018/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5_Array%20%26%20Matrix/images/0697%E6%80%9D%E8%B7%AF02.jpg)

```c
typedef struct {
    int key;
    int counter;
    int left, right;
    UT_hash_handle hh;
}HashTable;

int findShortestSubArray(int* nums, int numsSize) {
    HashTable* hashTable = NULL;
    for (int i = 0; i < numsSize; i++) {
        HashTable* tmp;
        HASH_FIND_INT(hashTable, &nums[i], tmp);
        if (tmp != NULL) {
            tmp->counter++;
            tmp->right = i;
        } else {
            tmp = (HashTable*)malloc(sizeof(HashTable));
            tmp->key = nums[i];
            tmp->counter = 1;
            tmp->left = i;
            tmp->right = i;
            HASH_ADD_INT(hashTable, key, tmp);
        }
    }
    int maxNum = 0, minLen = 0;
    HashTable *s, *tmp;
    HASH_ITER(hh, hashTable, s, tmp) {
        if (maxNum < s->counter) {
            maxNum = s->counter;
            minLen = s->right - s->left + 1;
        } else if (maxNum == s->counter) {
            if (minLen > s->right - s->left + 1) {
                minLen = s->right - s->left + 1;
            }
        }
    }
    return minLen;
}

```

【代码分析】

![0697code01](https://github.com/YuCaiH/LeetCode_CyC2018/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5_Array%20%26%20Matrix/images/0697code01.jpg)

![0697code02](https://github.com/YuCaiH/LeetCode_CyC2018/blob/main/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A9%E9%98%B5_Array%20%26%20Matrix/images/0697code02.jpg)

